A. For this solution I used a Nearest Neighbor algorithm.

B1. 1. Loop throught the packages in the truck and add the truck number, initial status, and load 
        time to each package.
     2. While the truck list is not empty, look at each package and determine the distance between 
        the truck and the address. If that distance is less than the current smallest distance, 
        make that package the next to be delivered.
     3. Once the next package is found, add the delivery time to the current truck time, timestamp
        the package, change the status, change the truck location, remove the package from the
        truck list, and update the total distance traveled.
     4. Repeat for each truck.

    for i in truck list
        package = package[i]
        package truck number = truck number
        package status = status
        package load time = load time
    while truck list > 0
        for i in truck list
            package = package[i]
            current distance = distance between truck and next package
            if current distance < current minimum distance 
                minimum package = current package
                minimum distance = current distance
        current time = (minimum distance / 18) * 60
        truck time = truck time + current time
        minimum package delivery time = truck time
        minimum package status = Delivered
        truck location = package address
        truck list pop(minimum package)
        distance traveled = distance traveled + minimum distance
    return distance traveled, truck time

B2. For this project I used Python 3 in a replit.com environment. The hardware varied depending on 
        when I was working on this project. For the majority of this project I used a laptop with Windows 10, Intel I7 processor,
        16GB of ram, and a 500GB SSD.
B3. loadPackageData: O(n)
     loadDistanceData: O(n)
     loadAddressData: O(n)
     addressDistance: O(n)
     deliver: O(n^2)
     Interface choice 1: O(n)
     Interface choice 2: O(n)
     Interface choice 3: O(n)
     Overall: O(n^2)
B4. I do not see an issue with the scalability of the delivery algorithm itself. The only issue
     would be needing a better solution for assigning packages to trucks other than manually assignment.
     As packages are added, the has table would grow as needed as long as there is enough available memory in the 
     host system.
B5. I believe my decision to break certain portions down into smaller chunks (functions) will lend
     to this code being effecient and easier to maintain compared to repeating code when it's needed.
B6. The hash table, specifically the linking hash table, can store large amounts of data very well 
     without overwriting or causing collisions with other data locations. However, with the increased 
     time and resources needed to hash and unhash data, it may not be as efficient as something like 
     a plain array.

D. For the package objects, I am using a chaining hash table. That allows me to store all of the objects
   without collisions.
D1. For the relationship between data points, the hash table will store each object in the bucket corresponding to the 
    hash generated by the package id. Two or more objects will live in the same bucket, and can be accessed by finding 
    the hash, going to that bucket, and finding the obect by the id.

I. 1. It is a greedy algorithm which means it will heuristically pick a short distance. Although this solution
        will result in a short solution, it will not result in the optimal solution, which is a drawback of greedy algorithms.
        It is also a fairly simple algorithm to think through logically and implement.
   2. Verified.
   3. Dijkstra involves creating nodes and pathways to said nodes instead of looping through a list, 
        and a depth-first algorithm involves creating nodes and branches and removing each node after it is used.

J. The main thing I would do differently would be to split up and organize the code into files instead of 
    keeping everything in one file.

K 1a. The more packages to look through, the longer the potential time required to find a package.
   b. If the number of packages increases, the hash table will need more memory to store the objects.
   c. I don't think changing the number of truck or cities would impact the lookup time. Maybe a slight impact on 
        space usage, if the distance had to change from an int to something longer (like a long in Java).
  2. Instead of a hash table, an array could be used, but it would be inefficient because the lookup would have
        to search the entire array each itteration. A linked list could also be used, although that could be 
        potentially faster than an array because of the previous and next markers, it would still be worse than
        the hash table.
